<html lang="en">

<head>
    <meta charset="utf-8" http-equiv="X-UA-Compatible" content="IE=10" />

    <style>
        html, body {
            height: 100%;
            margin: 0;
        }

        body {
            background-color: #fff;
            font-family: sans-serif;
            overflow: hidden;
        }

        h1 {
            font-weight: normal;
            font-size: 140%;
        }

        table {
            height: 100%;
            width: 100%;
        }

        #blocklyArea {
            height: 99%;
        }
    </style>
</head>

<body>
    <table>
        <tr>
            <td id="blocklyArea">
            </td>
        </tr>
    </table>

    <div id="blocklyDiv" style="position: absolute"></div>

    <script>
        var workspace;
        function init(preview) {
            blocklyArea = document.getElementById('blocklyArea');
            var blocklyDiv = document.getElementById('blocklyDiv');

            if (preview) { // Only if preview is set to true should we hide the trashcan
                workspace = Blockly.inject(blocklyDiv,
                    {
                        zoom:
                        {
                            controls: false,
                            startScale: 1.0,
                            maxScale: 3,
                            minScale: 0.3,
                            scaleSpeed: 1.2,
                            pinch: false
                        },
                        trashcan: false
                    });
            }
            else {
                workspace = Blockly.inject(blocklyDiv,
                    {
                        zoom:
                        {
                            controls: true,
                            startScale: 1.0,
                            maxScale: 3,
                            minScale: 0.3,
                            scaleSpeed: 1.2,
                            pinch: true
                        },
                        trashcan: true
                    });
            }

            var onresize = function (e) {
                // Compute the absolute coordinates and dimensions of blocklyArea.
                var element = blocklyArea;
                var x = 0;
                var y = 0;
                do {
                    x += element.offsetLeft;
                    y += element.offsetTop;
                    element = element.offsetParent;
                } while (element);
                // Position blocklyDiv over blocklyArea.
                blocklyDiv.style.left = x + 'px';
                blocklyDiv.style.top = y + 'px';
                blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
                blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
                Blockly.svgResize(workspace);

                console.log('resize');
            };

            window.addEventListener('resize', onresize, false);
            onresize();
            Blockly.svgResize(workspace);


        }

        function addNewBlockToArea(text, type) {

            if (type === 'custom_object' || type === 'custom_function') {
                type = type + "_" + text;
            }

            newBlock = workspace.newBlock(type);
            newBlock.initSvg();
            newBlock.render();

        }

        function addCustomBlockToArea(text, type, color) {
            let typeArr = type.split('_');
            if (typeArr[1] === 'object') {
                // add a new block for custom_object
                Blockly.defineBlocksWithJsonArray([{
                    "type": "custom_object_" + text,
                    "message0": "%1",
                    "args0": [
                        {
                            "type": "field_input",
                            "name": "object_name",
                            "text": text,
                        }
                    ],
                    "output": "String",
                    "colour": color,
                    "tooltip": "",
                    "helpUrl": ""
                }]);

                Blockly.CSharp["custom_object_" + text] = function (block) {
                    var text_object_name = block.getFieldValue('object_name');
                    // TODO: Assemble JavaScript into code variable.
                    var code = text_object_name;
                    // TODO: Change ORDER_NONE to the correct strength.
                    return [code, Blockly.CSharp.ORDER_ATOMIC];
                };
            } else if (typeArr[1] === 'function') {
                Blockly.Blocks[type] = {
                    /**
                     * Block for defining a custom function and generate custom blocks based on this function
                     */
                    init: function () {
                        this.setPreviousStatement(true, null);
                        this.setNextStatement(true, null);
                        // Ensure two identically-named procedures don't exist.
                        var initName = Blockly.Procedures.findLegalName(typeArr[2], this);
                        // If the name of function is changed, rename any callers.
                        var nameField = new Blockly.FieldTextInput(initName,
                            Blockly.Procedures.rename);
                        nameField.setSpellcheck(false);

                        this.appendDummyInput()
                            .appendField('custom function')
                            .appendField(Blockly.Msg['PROCEDURES_DEFRETURN_TITLE'])
                            .appendField(nameField, 'NAME')
                            .appendField('', 'PARAMS');
                        this.appendValueInput('RETURN')
                            .setAlign(Blockly.ALIGN_RIGHT)
                            .appendField(Blockly.Msg['PROCEDURES_DEFRETURN_RETURN'])
			                .setCheck(null);
                        this.setMutator(new Blockly.Mutator(['procedures_mutatorarg']));
                    if((this.workspace.options.comments ||
                        (this.workspace.options.parentWorkspace &&
                            this.workspace.options.parentWorkspace.options.comments)) &&
                    Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']) {
                    this.setCommentText(Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']);
                }
                this.setStyle('procedure_blocks');
                this.setTooltip(Blockly.Msg['PROCEDURES_DEFRETURN_TOOLTIP']);
                this.setHelpUrl(Blockly.Msg['PROCEDURES_DEFRETURN_HELPURL']);
                this.arguments_ = [];
                this.argumentVarModels_ = [];
                this.setStatements_(false);
                this.statementConnection_ = null;
                },

                /**
                * Add or remove the statement block from this function definition.
                * @param {boolean} hasStatements True if a statement block is needed.
                * @this {Block}
                */
                setStatements_: Blockly.Blocks['procedures_defnoreturn'].setStatements_,
                /**
                * Update the display of parameters for this procedure definition block.
                * @private
                * @this {Block}
                */
                updateParams_: Blockly.Blocks['procedures_defnoreturn'].updateParams_,
                /**
                    * Create XML to represent whether this block has a return value.
                    * @return {!Element} XML storage element.
                    * @this {Blockly.Block}
                    */
                mutationToDom: Blockly.Blocks['procedures_defnoreturn'].mutationToDom,
                /**
                * Parse XML to restore the argument inputs.
                * @param {!Element} xmlElement XML storage element.
                * @this {Blockly.Block}
                */
                domToMutation: Blockly.Blocks['procedures_defnoreturn'].domToMutation,
                /**
                * Populate the mutator's dialog with this block's components.
                * @param {!Blockly.Workspace} workspace Mutator's workspace.
                * @return {!Blockly.Block} Root block in mutator.
                * @this {Blockly.Block}
                */
                decompose: Blockly.Blocks['procedures_defnoreturn'].decompose,
                /**
                    * Reconfigure this block based on the mutator dialog's components.
                    * @param {!Blockly.Block} containerBlock Root block in mutator.
                    * @this {Blockly.Block}
                    */
                compose: Blockly.Blocks['procedures_defnoreturn'].compose,
                /**
                    * Return the signature of this procedure definition.
                    * @return {!Array} Tuple containing three elements:
                    *     - the name of the defined procedure,
                    *     - a list of all its arguments,
                    *     - that it DOES have a return value.
                    * @this {Blockly.Block}
                    */
                getProcedureDef: function () {
                    return [this.getFieldValue('NAME'), this.arguments_, true];
                },
                /**
                * Return all variables referenced by this block.
                * @return {!Array<string>} List of variable names.
                * @this {Blockly.Block}
                */
                getVars: Blockly.Blocks['procedures_defnoreturn'].getVars,
                /**
                * Return all variables referenced by this block.
                * @return {!Array<!Blockly.VariableModel>} List of variable models.
                * @this {Blockly.Block}
                */
                getVarModels: Blockly.Blocks['procedures_defnoreturn'].getVarModels,
                /**
                * Notification that a variable is renaming.
                * If the ID matches one of this block's variables, rename it.
                * @param {string} oldId ID of variable to rename.
                * @param {string} newId ID of new variable.  May be the same as oldId, but
                *     with an updated name.  Guaranteed to be the same type as the old
                *     variable.
                * @override
                * @this {Blockly.Block}
                */
                renameVarById: Blockly.Blocks['procedures_defnoreturn'].renameVarById,
                /**
                * Notification that a variable is renaming but keeping the same ID.  If the
                * variable is in use on this block, rerender to show the new name.
                * @param {!Blockly.VariableModel} variable The variable being renamed.
                * @package
                * @override
                * @this {Blockly.Block}
                */
                updateVarName: Blockly.Blocks['procedures_defnoreturn'].updateVarName,
                /**
                * Update the display to reflect a newly renamed argument.
                * @param {string} oldName The old display name of the argument.
                * @param {string} newName The new display name of the argument.
                * @private
                * @this {Blockly.Block}
                */
                displayRenamedVar_: Blockly.Blocks['procedures_defnoreturn'].displayRenamedVar_,
                /**
                * Add custom menu options to this block's context menu.
                * @param {!Array} options List of menu options to add to.
                * @this {Blockly.Block}
                */
                customContextMenu: Blockly.Blocks['procedures_defnoreturn'].customContextMenu,
                callType_: 'procedures_callreturn'
                };
            }


        }

        function showCode(language) {

            var code = "";

            if (language === ".js") {
                code = Blockly.JavaScript.workspaceToCode(workspace);
            } else if (language === ".py") {
                code = Blockly.Python.workspaceToCode(workspace);
            } else if (language === ".php") {
                code = Blockly.PHP.workspaceToCode(workspace);
            } else if (language === ".cs") {
                code = Blockly.CSharp.workspaceToCode(workspace);
            }

            return code;

        }
    </script>
</body>
</html>